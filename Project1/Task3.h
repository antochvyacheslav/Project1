#pragma once

//Решение 3 задачи.
//Реализуйте функции сериализации и десериализации двусвязного списка в бинарном формате в файл.Алгоритмическая сложность решения должна быть меньше квадратичной.
//Примечание: сериализация подразумевает сохранение и восстановление полной структуры списка, включая взаимное соотношение его элементов между собой.

//Мои примечания по 3 задаче:
//!1. для сохранения полной структуры списка, включая взаимное расположение его элементов между собой будет использоваться вычислиение порядковых номеров узлов,
//! понятно, что контейнер типа List не предусматривает возможности доступа по индексу, поэтому вычисление порядковых номеров узлов используется только при сериализации/десериализации для сохранения и восстановления полной структуры списка,
//! т.е. происходит высчитывание номеров узлов на момент сериализации/десериализации, чтобы сохранить/восстановить текущее состояние списка только в эти два момента.
//!2. метод добавления данных в конец списка (AddToEnd) сделан шаблоном, потому что для проверки нужно заносить какие-то тестовые данные, и это удобнее через стандартные си-строки - list1.AddToEnd("_a_");
//! но также метод добавления нужен при десериализации, и там уже в функцию передаётся указатель на строку string, и т.к. код в обоих случаях одинаковый, и отличается только сохранением данных data, то решил, 
//! что более красивый вариант будет, если сделать шаблон функции, чем придумывать другой способ заполнения тестовыми значениями или перегружать метод SetData и копировать код, который бы различался только установкой значения data
//!3. для сериализации и десериализаци сложность меньше квадратичной (нет цикла по всем узлам, внутри которого второй цикл тоже перебирал все узлы)
//! *для сериализаци для получения номера указателя на произвольный элемент списка добавлен контейнер map, который хранит пары указатель на узел и порядковый номер узла
//! *для десериализации для восстановления указателя на случайный элемент списка добавлено два контейнера типа vector, один для хранения указателей на узлы, второй для хранения порядковых номеров случайных узлов
//!4. работа с памятью при десериализации - при считывании данных (string) из файла, память теперь выделяется один раз, затем она сохраняется в список с помощью семантики перемещения (move)

#include "List.h"