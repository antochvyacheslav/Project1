#pragma once

#include <cstdio>
#include <cstring>
#include <typeinfo>

//Решение 1 задачи.
//Напишите функцию, которая принимает на вход знаковое целое число и печатает его двоичное представление, не используя библиотечных классов или функций.

//Мои примечания по решению первой задачи:
//-первый вариант - когда на работе для более удобной отладки в паре мест мне для удобства хотелось выводить маску в двоичном формате, добавил битовую структуру и через неё трассировал.
//Для отладки на изделии стояла МСВС 3 и там была старая версия компилятора gcc, которая не поддерживал никакой стандартный вывод в двоичном формате.
//-второй вариант - так я делал в политехе на лабах.
//По мне первый вариант более наглядный.
//-Ещё пояснение по поводу сохранения значений в буфер перед выводом - 
//на работе вся трассировка у нас идёт через макросы TRACE, DEBUG, WARNING, ERROR, которые печатают строчку целиком, т.е. там нельзя вызывать их для печати по одному символу в строчку,
//поэтому мне привыченее и кажется лучше уметь формировать буфер и потом его отправлять на печать в трассу, а не печать по одному символу.

//битовая структура для трассировки байта
struct Byte {
	unsigned char b0 : 1;
	unsigned char b1 : 1;
	unsigned char b2 : 1;
	unsigned char b3 : 1;
	unsigned char b4 : 1;
	unsigned char b5 : 1;
	unsigned char b6 : 1;
	unsigned char b7 : 1;
};

//шаблон функции, которая принимает на вход знаковое целое число и печатает его двоичное представление, не используя библиотечных классов или функций
template <typename T>
void TraceSignedNumToBinaryFormat(T num) {
	//вычисление размера буфера для хранения данных:
	//8 байт под бинарное значение ("0" или "1") + 2 байта под пробел после каждой тетрады (после каждых 4 бит) + 1 байт в конце под символ конца строки
	unsigned int len = sizeof(num) * 8 + sizeof(num) * 2 + 1;
	char* str = new char[len];
	memset(str, 0, len);
	//для вывода двоичного представления будет ипользоваться обратный порядок байт
	for (int i = sizeof(num) - 1; i >= 0; i--) {
		char* pNum = (char*)&num + i;
		Byte* pByte = (Byte*)pNum;
		sprintf(str + strlen(str), "%d%d%d%d %d%d%d%d ", pByte->b7, pByte->b6, pByte->b5, pByte->b4, pByte->b3, pByte->b2, pByte->b1, pByte->b0);
	}
	//убрать последний пробел
	str[strlen(str) - 1] = '\0';
	//в десятичном и шестнадцатеричном виде в начале выводится дополнительно для удобства проверки
	printf("num 0d%011d 0x%08x in bin=0b[%s] [type:%s]\n", num, num, str, typeid(T).name());
	delete[] str;
}

//функция, которая принимает на вход знаковое целое число и печатает его двоичное представление, не используя библиотечных классов или функций
void TraceIntToBinaryFormat(int num) {
	//вычисление размера буфера для хранения данных:
	//8 байт под бинарное значение ("0" или "1") + 2 байта под пробел после каждой тетрады (после каждых 4 бит) + 1 байт в конце под символ конца строки
	unsigned int len = sizeof(num) * 8 + sizeof(num) * 2 + 1;
	char* str = new char[len];
	memset(str, 0, len);
	unsigned int mask = 0x01 << (sizeof(num) * 8 - 1);
	//маска для группировки в трассе по тетрадам (по 4 бита) [для более удобной читаемой трассы]
	unsigned int cnt_mask = 0x01 << (sizeof(num) * 8 - 1 - 4);
	while (mask) {
		sprintf(str + strlen(str), "%d", ((num & mask) ? 1 : 0));
		mask >>= 0x01;
		//вставить пробел после каждой тетрады
		if (mask & cnt_mask) {
			sprintf(str + strlen(str), " ");
			cnt_mask >>= 0x4;
		}
	}
	//в десятичном и шестнадцатеричном виде в начале выводится дополнительно для удобства проверки
	printf("num 0d%011d 0x%08x in bin=0b[%s]\n", num, num, str);
	delete[] str;
}